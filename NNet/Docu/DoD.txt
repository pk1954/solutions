Version 5.2 9.1.2024:

sizeof(bool) 1 bytes
sizeof(Nob) 32 bytes
sizeof(FixedPipeline<mV>) 32 bytes
fork             size    72 count   626 sum   45072 bytes
inputLine        size    64 count    86 sum    5504 bytes
outputLine       size    56 count    82 sum    4592 bytes
knot             size    64 count   394 sum   25216 bytes
inputConnector   size    64 count    15 sum     960 bytes
   input conn lists                           15360 bytes
outputConnector  size    64 count     0 sum       0 bytes
   output conn lists                              0 bytes
neuron           size    88 count   162 sum   14256 bytes
   pipe lists                                  1296 bytes
synapse          size   176 count   630 sum  110880 bytes
   blocklists                                     0 bytes
pipe             size    88 count  2524 sum  222112 bytes
   segments                                   10152 bytes
Model                                           304 bytes
ModelSize                                    455704 bytes

t1 = 33.40 μs
t2 = 33.80 μs
tC = 67.30 μs
tX = 82.50 μs
xxxxxxxxxxxxxxxxxxxxxx

CompStep:
Knot	do nothing
Fork do nothing
IoLine do nothing
IoConnector do nothing

bool Pipe::CompStep()
{
	PushVoltage(m_mVpotential);
	return false;
}

bool Neuron::CompStep()
{
	bool bTrigger { m_mVpotential >= GetParam()->Threshold() };

	if (bTrigger)
	{
		m_usSpikeTime = 0.0_MicroSecs;
		m_bTriggered  = true;
		m_mVpotential.Set2Zero();
	}
	else
	{
		m_usSpikeTime += GetParam()->TimeResolution();
	}

	return m_bStopOnTrigger && bTrigger;
}

bool Synapse::CompStep()
{
	static const mV PULSE_THRESHOLD { 0._mV };
	
	mV mVfromBuffer = m_pulseBuffer.Get();
	m_mVpotential += mVfromBuffer;

	bool bSignal      { (m_mVpotential > PULSE_THRESHOLD) };
	bool bInPulseDist { SimulationTime::Get() - m_usBlockStartTime < GetParam()->PulseDistMin() };

	switch (m_state)
	{
		using enum tState;
	case idle:
		if (bSignal)
			startLeadPulse();
		break;

	case leadPulse:
		if (!bInPulseDist)
		{
			m_state = idle;  // leading pulse longer than min pulse dist!
		}
		else if (!bSignal)
		{
			block();
			m_state = blockedIdle;
		}
		break;

	case blockedIdle:
		if (bSignal)
		{
			m_mVpotential.Set2Zero();  // block this pulse
			if (bInPulseDist)
				m_state = blockedPulse;
			else
				startLeadPulse();
		}
		else
		{
			if (!bInPulseDist)    // block time over and no signal: unblock
				unblock();
		}
		break;

	case blockedPulse:
		if (bSignal)
		{
			m_mVpotential.Set2Zero();  // block this pulse
			if (!bInPulseDist)
				m_state = trailPulse; 
		}
		else   // blocked pulse ended 
		{
			if (bInPulseDist)
				m_state = blockedIdle;  
			else            
				unblock();   // block time over and no signal: unblock
		}
		break;

	case trailPulse:
		if (bSignal)
			m_mVpotential.Set2Zero();  // block this pulse
		else 
			unblock();
		break;
	}

	return false;  // no stop on trigger
}



